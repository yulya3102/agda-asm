# Introduction

Верификация программного обеспечения может быть трудной задачей, и потому
ей не всегда уделяют должное внимание. Тем не менее, для некоторого класса
программного обеспечения трудозатраты на верификацию могут оказаться
стоящими результата. Например, одним из таких классов являются инструменты
разработки (тулчейны), потому что, во-первых, ошибки в них труднонаходимы,
и во-вторых, тулчейны являются частоиспользуемым ПО, в том числе и в сферах
с высокой ценой ошибки.

В настоящее время ведутся работы по созданию верифицированных тулчейнов, но
пока человечество далеко от создания абсолютно надежного комплекса
инструментов разработки программ. Например, есть VeLLVM [@vellvm],
формализующий язык LLVM и производящий доказанно корректные оптимизации в
нем. Есть более близкий к реальным тулчейнам проект, компилятор языка C
CompCert [@compcert], производящий оптимизации, доказанно сохраняющие
семантику програмы. Тем не менее, даже CompCert не покрывает сборку
программы целиком: он использует системный, не верифицированный, линковщик.

Может показаться, что линковщик является достаточно простой программой, в
которой трудно ошибиться. Возможно, так и было до тех пор, пока не начали
производить оптимизации на этапе линковки. Эти оптимизации усложняют логику
линковщика, и в итоге он перестает быть простой программой. Возможность
наличия ошибок в коде линковщика подтверждается практикой: недавно
проводилось исследование [@ltostress], в котором делали стресс-тесты для
линковщиков, и в итоге было найдено огромное количество ошибок на этапе
оптимизаций во время линковки. Это показывает, что верификацией линковщиков
не стоит пренебрегать.

Линковщик — достаточно низкоуровневая программа, которая работает с
скомпилированными в машинный код объектными файлами, а значит, для
рассуждений про него необходима формализация низкоуровнего языка, очень
близкого к машинному коду. Одной из заметных работ в этой области является
Bedrock [@bedrock], являющийся библиотекой на Coq [@coq], позволяющей
оперировать абстракциями, ассоциированными с языком ассемблера, и писать
код в рамках этих абстракций. В рамках проекта Bedrock была реализована
поддержка линковки с внешними библиотеками [@bedrocklinkers], но не было
формализовано механизмов динамической линковки, широко используемой в
настоящее время.

Так же существует отличная формализация ассемблера — Typed Assembly
Language (TAL) [@tal], описывающая некоторый низкоуровневый язык как
типизированный язык, поддерживающий высокоуровневые абстракции, таких как
переменные типов и кортежи. В этом направлении было сделано множество
работ, расширяющих язык TAL, покарывающих, например, работу со стеком (STAL)
[@stal], практически настоящий язык ассемблера x86 (TALx86) [@talx86] и даже
раздельную компиляцию и работу с объектными файлами (MTAL) [@mtal]. В работе,
описывающей модульный язык ассемблера (MTAL), была описана статическая
линковка различных объектных файлов, но формализации механизмов
динамической линковки, как и в Bedrock, представлено не было.

TAL является хорошей моделью для рассуждений про исполнение низкоуровневого
кода, но, к сожалению, существующие утилиты, реализуюущие работу с TAL,
написаны на ML, а все доказательства про работу программ на TAL приводились
в виде приложений в соответствующих статьях. В этой статье используется
формализация на Agda [@agda] абстрактного языка, близкого к TALx86 и STAL.
В рамках этого языка определяется, какие элементы добавляются в программу в
процессе динамической линковки, вводится понятие эквивалентности различных
программ и доказывается, что при правильно работающем динамическом
загрузчике статически и динамически слинкованнаые программы оказываются
эквивалентными.

Эту работу можно считать первыми шагами в области формализации динамической
линковки, из чего впоследствии можно получить верифицированный линковщик,
использующий внутри себя некоторую математическую модель, позволяющую
говорить о корректности производимых линковщиком преобразований программы.
