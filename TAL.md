# Обзор используемой формализации TAL

Оригинальный Typed Assembly Language был достаточно выразительным для
реализации возможностей высокоуровневых языков, таких как параметрический
полиморфизм или пользовательские структуры данных. Для нашей задачи эти
возможности не являются существенными, но вместо этого возникает
необходимость наличия определенных типов данных и инструкций, используемых
в реализации динамической линковки. В связи с этим используемая
формализация TAL имеет несколько существенных отличий от оригинального
Typed Assembly Language.

Первым отличием является отсутствие параметров типов. Это является
значительным упрощением исходного языка, позволяющим сильно упростить
используемую формализацию. Тем не менее, динамический линковщик не
нуждается в полиморфизме на уровне языка ассемблера: он не интерпретирует и
не меняет данный ему код, всего лишь добавляя к нему дополнительные
элементы.

Вторым отличием является отсутствие кортежей в памяти, в которых
динамический линковщик также не нуждается. Вместе с типом кортежа из языка
удаляются неинициализированные значения и метки инициализированности.

Действительно необходимой для формализации динамической линковки является
семантика инструкции непрямого перехода, позволяющая динамически менять
целевую точку передачи исполнения. Аргументом этой инструкции является
указатель на ячейку памяти, в которой находится указатель на блок кода,
который необходимо исполнить. Для корректной типизации этой инструкции в
поддерживаемые типы данных необходимо добавить тип указателя на
типизированную ячейку памяти (тип \C{\_*} в листинге \ref{fig:types}), и
это является третьим отличием.

Динамическая линковка добавляет в объектные файлы код-"прослойку" между
различными библиотеками, исполняемый при вызове внешних функций. Этот код
не должен никак влиять на семантику программы. Это означает, что мы не
можем абстрагироваться от стека вызовов, который может быть "испорчен"
вызовом "лишних" процедур. Программы оригинального TAL, помимо исполняемой
последовательности инструкций, включали в себя состояния регистров и
памяти. В используемой формализации они дополнительно включают в себя
состояние стека, который для простоты реализации был разделен на две части:
стек данных и стек вызовов. Типы ожидаемых стека данных и стека вызовов так
же добавляются в параметры типа последовательности инструкций (тип
\C{block} в листинге \ref{fig:types}), который в оригинальном TAL содержал
только ожидаемый тип регистров, и это последнее существенное отличие
используемой формализации от оригинального TAL.

Часть программы, не содержащая исполняемой последовательности инструкций,
будем называть состоянием исполнителя. Тип состояния исполнителя приведен в
листинге \ref{fig:statetype}.
