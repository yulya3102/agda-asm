# Linking primer

Данная работa формализует упрощенный вариант динамической линковки,
используемой в файлах ELF и описанной в [@dsohowto]. В этом упрощенном
варианте поддерживается только линковка внешних функций и не подерживаются
внешние переменные.

Динамическая линковка предполагает использование внешних символов из
библиотек без включения внешних библиотек в объектный файл, как это было бы
при статической линковке. При этом динамическому линковщику необходимо
чем-то заполнить "пустые" аргументы инструкций перехода на внешние функции
из объектного файла, сделав их пригодными к исполнению. Для этого
динамический линковщик на каждую внешнюю функцию $f$ добавляет
дополнительную процедуру $f.linkage$ и статическую ячейку памяти
$f.offset$. Процедура $f.linkage$ содержит в себе единственную инструкцию:
indirect jump по указателю $f.offset$. Если в $f.offset$ находится
правильный адрес загруженной в память внешней функции $f$, то исполнение
процедуры $f.linkage$ приведет к исполнению функции $f$.

После такого преобразования для вызова внешней функции $f$ все еще
необходимо заполнить ячейку памяти $f.offset$. Но это существенно
отличается от исходного неслинкованного объектного файла: заполнить
undefined символы исходного файла можно было только до запуска программы, в
то время как заполнить ячейку $f.offset$ можно и в рантайме. В этом и
состоит важность инструкции indirect jump: она позволяет в рантайме менять
целевую точку инструкций перехода.

Процедуры $f.linkage$ всех внешних функций $f$ группируются в одну секцию,
которая называется PLT (Procedure Linkage Table), а ячейки $f.offset$
группируются в секцию GOT (Global Offset Table).

Динамический линковщик совершает подобное преобразование над объектными
файлами, и на этом его работа заканчивается. После этого в рантайме
динамический загрузчик заполняет секции GOT загруженных библиотек, и код
становится полностью пригодным для исполнения.
