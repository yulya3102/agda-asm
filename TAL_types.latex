\iftoggle{russian-draft}{
Все поддерживаемые типы данных указаны в листинге \ref{fig:types}.
В нашей формализации типы данных описываются двумя разными дататайпами:
\F{RegType} и \F{Type}. \F{RegType} описывает только типы размером с
регистр и используется для корректной типизации таких инструкций, как,
например, копирование значения из ячейки памяти в регистр. \F{Type}
описывает типы произвольного размера, которые включают в себя типы размером
с регистр (с помощью конструктора \C{atom}).

Действительно необходимой для формализации динамической линковки является
семантика инструкции непрямого перехода, позволяющая динамически менять
целевую точку передачи исполнения. Аргументом этой инструкции является
указатель на ячейку памяти, в которой находится указатель на блок кода,
который необходимо исполнить. Для корректной типизации этой инструкции в
поддерживаемые типы данных необходимо добавить тип указателя на
типизированную ячейку памяти (тип \C{\_*} в листинге \ref{fig:types}), и
это является третьим отличием. По сути, это тип кортежа из оригинального
TAL, но фиксированной длины и без метки инициализированности.

Динамическая линковка добавляет в объектные файлы код-"прослойку" между
различными библиотеками, исполняемый при вызове внешних функций. Этот код
не должен никак влиять на семантику программы. Это означает, что мы не
можем абстрагироваться от стека вызовов, который может быть "испорчен"
вызовом дополнительных процедур. \emph{Состояние программы} оригинального TAL, помимо исполняемой
последовательности инструкций, включали в себя состояния регистров и
памяти. В используемой формализации они дополнительно включают в себя
состояние стека, который для простоты реализации был разделен на две части:
стек данных и стек вызовов. Кроме того, конструктор типа последовательности
инструкций имеет дополнительные аргументы по сравнению с оригинальным TAL.
В используемой формализации аргументами конструктора типа
последовательности инструкций являются ожидаемые типы регистров, стека
данных и стека вызовов (конструктор \C{code} в листинге \ref{fig:types}), в
то время в оригинальном TAL в аргументах отсутствовали типы стеков.
Это еще одно существенное отличие
используемой формализации от оригинального TAL.
}{
\textbf{TODO}.

What is really necessary for dynamic linking formalization is indirect jump
instruction semantics. This instruction allows to dynamically change target
executable code. The argument of this instruction is a pointer to a memory
location where the address of target executable code is stored. To
correctly type indirect jump instruction we need to support the type of
pointer to typed memory (the type \C{\_*} from listing \ref{fig:types}).
This is the third difference from the original Typed Assembly Language.
Essentially, this is the tuple type from the original TAL, but without
initialization flag and of fixed length.

\textbf{\emph{TODO:}}
Dynamic linker adds intermedium code between different libraries. This code
is called when external function is called. It must not affect program
semantics. Therefore, we can't hide call stack in abstractions, because it
can be affected by additional procedure calls. \emph{Programs} of original TAL
includes \emph{instruction sequence}, \emph{register files} and \emph{heaps}. Our
formalization additionally includes \emph{stack}, which is split in two parts:
\emph{data stack} and \emph{call stack}. Instruction sequence type from original TAL
contained only expected \emph{register file type}, but in our formalization
it contains also types of expected data stack and call stack, as shown
in \C{code} constructor of listing \ref{fig:types}. This is another
difference from original TAL.
}

\iftoggle{russian-draft}{
Часть \emph{состояния программы}, не содержащая исполняемой последовательности инструкций,
будем называть \emph{состоянием исполнителя}. Определение типа состояния
исполнителя \F{StateTyep} приведенo в листинге \ref{fig:statetype}.
Типы регистров (\F{RegFileTypes}), как и в оригинальном
TAL и STAL, описываются отображением из имен регистров в соответствующие
им типы. Аналогично, типы в памяти (\F{HeapTypes}) - это отображение из
указателей (меток) в соответствующие им типы. Типы стека данных
(\F{DataStackType}), как и в STAL, описываются списком типов,
соответствующим находящимся на стеке элементам. Типы стека вызовов
(\F{CallStackType}) описываются похожим списком, определяющим типы
указателей-адресов возврата. Так как данная статья фокусируется на описании
семантики динамической линковки, детали реализации этих отображений на Agda
здесь не описаны.

Основной сущностью, относящейся к коду, является \textbf{\emph{базовый
блок}}. Базовым блоком мы будем называть последовательность инструкций
общего назначения, завершающуюся инструкцией перехода. Этому понятию
соответствует термин \emph{последовательность инструкций}
(\emph{instruction sequence}) из оригинального TAL.

Для обеспечения корректности вызова функции $g$ в конце
блока кода (последовательности инструкций) $f$ необходимо понимать, как
блок $f$ типа $S_f$ меняет
типы регистров и стеков и может ли он к концу своего исполнения получить
ожидаемый функцией $g$ тип $S_g$. Для этого тип блока, кроме ожидаемых типов
регистров и стеков, хранит некоторое описание изменений типов различных
частей \emph{программы}, применяемое этим блоком. Это описание хранится в типе
\F{Diff}, параметром которого является тип состояния исполнителя, к
которому может применяться это изменение.
Индуктивное определение \emph{блока кода} приведено в листинге
\ref{fig:block}. Конструктор \C{↝} позволяет получить блок, состоящий из
одной инструкции перехода, применяющей изменение стека вызовов типа
\AgdaBound{c}. Для получения общего \F{Diff} из изменения стека вызовов,
специфичного для инструкции перехода, используется функция \F{csChg}.
Конструктор \C{\_∙\_} добавляет инструкцию общего назначения \AgdaBound{i} с
изменением \AgdaBound{c} к началу блока \AgdaBound{b}. При этом тип блока
\AgdaBound{b} должен получаться из типа инструкции \AgdaBound{i} после
применения к нему общего диффа, полученного из специфичного для
\AgdaBound{i} изменения \AgdaBound{c} с помощью функции \F{sChg}.
Применение диффа к типу выполняется с помощью функции \F{dapply}. В
результате получается блок с диффом, составленным из диффов инструкции
\AgdaBound{i} и блока \AgdaBound{b}, полученный с помощью функции
\F{dappend}.

Семантика приведенного языка ассемблера определяется двумя функциями,
описывающими семантику инструкций общего назначения \F{Instr} и инструкций
перехода \F{ControlInstr}. Каждому виду инструкций разрешено менять только
часть \emph{состояния программы} \F{State}. Соответственно, эти функции
принимают на вход \emph{состояние программы} и возвращают новое состояние
той части состояния программы, которую им разрешено менять.  Так, для
инструкций общего назначения результатом исполнения является кортеж из
состояния регистров, памяти и стека данных, а результатом исполнения
управляющих инструкций является пара из нового состояния стека вызовов и
следующего блока, который
нужно исполнить. Кроме того, семантика блока кода описывается похожим
образом: результатом исполнения блока является пара из нового состояния
исполнителя и блока, который нужно исполнить следующим.
}{
\emph{Machine state} is the part of the \emph{program} that does not
contain \emph{instruction sequence}. Its type is shown in listing
\ref{fig:statetype}. \textbf{TODO}

\textbf{TODO: block}

To ensurre that function $g$ call in the end of the \emph{block}
(\emph{instruction sequence}) $f$ is correct, we have to know how block $f$
of type $S_f$ changes register file types and stack types and whether it
can transform machine state type $S_f$ to expected by function $g$ machine
state type $S_g$. To achieve this, type of block should contain not only
expected types of register file and stack, but some description of how this
block changes differnet parts of machine state type. This description is
stored in datatype \F{Diff}, which takes as parameter machine state type
that can be changed by this \emph{diff}. Recursive definitoin of the
\emph{code block} is shown in listing \ref{fig:block}. \textbf{TODO}

Semantics of this assembly language is defined by two functions describing
semantics of regular instructions (\emph{instructions} from original TAL)
and branch instructions (last instructions in \emph{instruction sequence}
from original TAL). Each type of instruction is allowed to change only part
of \emph{program}, and execution result is described by the new state of
that part of the \emph{program}. So, some branch instruction execution
result is a pair of new call stack state and next block to execute.
Moreover, semantics of the block is described in the same manner: block
execution result is a pair of the new machine state and next block to
execute. TODO
}
