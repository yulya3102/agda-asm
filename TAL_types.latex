\iftoggle{russian-draft}{
Все поддерживаемые типы данных указаны в листинге \ref{fig:types}.
В нашей формализации типы данных описываются двумя разными Agda-типами:
\F{WordType} и \F{ArbitraryType}. Agda-тип \F{WordType} описывает только типы размером с
регистр и используется для корректной типизации таких инструкций, как,
например, копирование значения в регистр из ячейки памяти, которая может быть
потенциально произвольного размера. Agda-тип \F{ArbitraryType}
описывает типы произвольного размера, которые включают в себя типы размером
с регистр с помощью конструктора \C{atom}.
}{
All supported data types are shown in listing \ref{fig:types}. In our
formalization data types are described with two different Agda-types:
\F{WordType} and \F{ArbitraryType}. Agda-type \F{WordType} describes only
register-sized types. It is used to correctly type instructions like
\C{mov} from memory to register, when the memory can contain arbitrary-sized
types. Agda-type \F{ArbitraryType} describes types of arbitrary size, which
include register-sized types with constructor \C{atom}.
}

\iftoggle{russian-draft}{
Действительно необходимой для формализации динамической линковки является
семантика инструкции непрямого перехода, позволяющая динамически менять
целевую точку передачи исполнения. Аргументом этой инструкции является
указатель на ячейку памяти, в которой находится указатель на блок кода,
который необходимо исполнить. Для корректной типизации этой инструкции в
поддерживаемые типы данных необходимо добавить тип указателя на
типизированную ячейку памяти (конструтор \C{\_*} Agda-типа \F{WordType} в
листинге \ref{fig:types}).  Это является третьим отличием используемой
формализации от оригинального
TAL. По сути, это тип кортежа из оригинального
TAL, но фиксированной длины и без метки инициализированности.
}{
What is really necessary for dynamic linking formalization is indirect jump
instruction semantics. This instruction allows to dynamically change target
executable code. The argument of this instruction is a pointer to a memory
location where the address of target executable code is stored. To
correctly type indirect jump instruction we need to support the type of
pointer to typed memory (constructor \C{\_*} of Agda-type \F{WordType} from
listing \ref{fig:types}).  This is the third difference of our
formalization from the original Typed Assembly Language.
Essentially, this is the tuple type from the original TAL without the
initialization flag, but with fixed length.
}

\iftoggle{russian-draft}{
Динамическая линковка добавляет в объектные файлы код-"прослойку" между
различными библиотеками, исполняемый при вызове внешних функций. Этот код
не должен никак влиять на семантику программы. Это означает, что мы не
можем абстрагироваться от стека вызовов, который может быть "испорчен"
вызовом дополнительных процедур. \emph{Состояние программы} оригинального TAL, помимо исполняемой
последовательности инструкций, включало в себя состояния регистров и
памяти. В используемой формализации оно дополнительно включает в себя
состояние стека, который для простоты реализации был разделен на две части:
стек данных и стек вызовов. Кроме того, конструктор \C{code} Agda-типа
\F{ArbitraryType}, соответстующий типу последовательности
инструкций, имеет дополнительные аргументы по сравнению с оригинальным TAL.
В используемой формализации аргументами этого конструктора
являются ожидаемые типы регистров, стека данных и стека вызовов, в
то время в оригинальном TAL в аргументах отсутствовали типы стеков.
Это еще одно существенное отличие
используемой формализации от оригинального TAL.
}{
Dynamic linker adds intermedium code between different libraries. This code
is invoked when external function is called. It must not affect program
semantics. Therefore, we can't hide call stack in abstractions, because it
can be affected by additional procedure calls. \emph{Program state} of
original TAL includes currently executed \emph{instruction sequence},
\emph{register files} and \emph{heaps}. Our
formalization additionally includes stack, which is split in two parts:
\emph{data stack} and \emph{call stack}. Aside from that, constructor
\C{code} of Agda-type \F{ArbitraryType}, corresponding to the instruction
sequence type, has additional arguments.
Instruction sequence type from original TAL
contained only expected \emph{register file type}, but in our formalization
it contains also types of expected data stack and call stack. This is another
difference from original TAL.
}

\iftoggle{russian-draft}{
Часть \emph{состояния программы}, не содержащую исполняемой последовательности инструкций,
будем называть \emph{состоянием исполнителя}. Определение Agda-типа
\F{StateType}, описывающего тип состояния исполнителя, приведенo в листинге
\ref{fig:statetype}.
Типы регистров, описываемые Agda-типом \F{RegFileTypes}, как и в оригинальном
TAL и STAL, описываются отображением из имен регистров в соответствующие
им типы. Аналогично, типы элементов в памяти, описываемые Agda-типом
\F{HeapTypes} - это отображение из
указателей (меток) в соответствующие им типы. Типы стека данных,
описываемые Agda-типом \F{DataStackType}, как и в STAL, описываются списком
типов, соответствующим находящимся на стеке элементам. Типы стека вызовов,
описываемые Agda-типом \F{CallStackType}, описываются похожим списком,
определяющим типы
указателей-адресов возврата. Так как данная статья фокусируется на описании
семантики динамической линковки, детали реализации на Agda этих отображений
здесь не описаны.
}{
\emph{Machine state} is the part of the \emph{program state} that does not
contain \emph{instruction sequence}. Definition of Agda-type \F{StateType}
that describes type of machine state is shown in listing
\ref{fig:statetype}.
Types of registers, described by Agda-type \F{RegFileTypes}, as in original
TAL and STAL, are described by a mapping from register names to
corresponding types. In the same manner, types of memory elements,
described by Agda-type \F{HeapTypes} are a mapping from pointers (labels)
to corresponding types. Types of data stack are described by Agda-type
\F{DataStackType} and, as in STAL, are described by the list of types
corresponding to elements on stack. Types of call stack, described by
Agda-type \F{CallStackType}, are described by a similar list defining
types of return address pointers.
This paper focuses on description of dynamic linking semantics, so
implementations of these mappings are not described here.
}

\iftoggle{russian-draft}{
Разные инструкции меняют различные части состояния исполнителя. Инструкции,
определяющие, какой код будет исполняться дальше, будем называть
\emph{инструкциями перехода}, а все остальные инструкции —
\emph{инструкциями общего назначения}.
}{
Different instructions change different parts of machine state.
We will refer to instructions that define which code will be executed next
as \emph{branch instructions}. All other instructions we will call
\emph{general purpose instructions}.
}

\iftoggle{russian-draft}{
Так как линковка принимает во внимание только переходы между различными
частями загруженного в память кода, удобно ввести понятие \textbf{\emph{базового
блока}}. Базовым блоком мы будем называть последовательность инструкций
общего назначения, завершающуюся инструкцией перехода. Этому понятию
соответствует термин \emph{последовательность инструкций}
(\emph{instruction sequence}) из оригинального TAL. Тип базового блока
задается конструктором \C{code} Agda-типа \F{ArbitraryType} из листинга
\ref{fig:types} и описывает, в каком состоянии исполнителя может быть
исполнен этот блок.
}{
Since linking takes into account only jumps between different parts of
loaded executable code, it is useful to define \textbf{\emph{basic block}}.
Basic block is a sequence of general-purpose instructions followed by a
branch instruction. It corresponds to the \emph{instruction sequence} from
the original TAL. The type of a basic block is specified by the constructor
\C{code} of Agda-type \F{ArbitraryType} from listing \ref{fig:types}. It
describes in which state this block can be executed.
}

\iftoggle{russian-draft}{
Для обеспечения корректности вызова функции $g$ в конце
базового блока $f$ необходимо понимать, как блок $f$ типа $S_f$ меняет
типы регистров и стеков и может ли он к концу своего исполнения получить
ожидаемый функцией $g$ тип $S_g$. Для этого Agda-тип блока индексирован
некоторым описанием того, как этот блок меняет тип состояния
исполнителя. Это описание хранится в Agda-типе
\F{Diff}, параметром которого является тип состояния исполнителя, к
которому может применяться это изменение.
Индуктивное определение Agda-типа \emph{блока кода} приведено в листинге
\ref{fig:block}. Конструктор \C{↝} позволяет получить блок, состоящий из
одной инструкции перехода \V{i}, применяющей изменение стека вызовов типа
\V{c}. В сигнатуре этого конструктора выражение \F{csChg} \V{S}
\V{c} преобразовывает изменение стека вызовов \V{c} в общее
изменение \F{Diff} состояния исполнителя типа \V{S}.
Конструктор \C{\_∙\_} добавляет инструкцию общего назначения \AgdaBound{i} с
изменением \AgdaBound{c} к началу блока \AgdaBound{b}. При этом тип блока
\AgdaBound{b} должен получаться из типа инструкции \AgdaBound{i} после
применения к нему соответствующего этой инструкции изменения \V{c} с
помощью функции \F{dapply}, что показано в типе блока \V{b}. В типе этого
блока выражение \F{sChg} \V{c}, аналогично предыдущему конструктору,
преобразовывает специфичное для инструкции \V{i} изменение \V{c} в общее
изменение состояния исполнителя, описываемое Agda-типом \F{Diff}. В
результате получается блок с изменением, составленным с помощью функции
\F{dappend} из изменений инструкции \AgdaBound{i} и блока \AgdaBound{b}.
}{
To ensure that function $g$ call at the end of the basic block
$f$ is correct, we have to know how block $f$
of type $S_f$ changes register file types and stack types and whether it
can transform machine state type $S_f$ to machine state type $S_g$ expected
by function $g$. To achieve that, Agda-type of block is indexed by some
description of how this
block changes differnet parts of the machine state type. This description is
stored in Agda-type \F{Diff}, which takes as parameter machine state type
that can be changed by this diff. Recursive definition of the Agda-type of
\emph{basic block} is shown in listing \ref{fig:block}.
Constructor \C{↝} allows to construct a block consisting of a single branch
instruction \V{i} that changes type of call stack by change \V{c}.
Expression \F{csChg} \V{S} \V{c} of this constructor transforms call
stack change \V{c} into common diff \F{Diff} of machine state of type
\V{S}.
Constructor \C{\_∙\_} adds general-purpose instruction \V{i} with change
\V{c} to the beginning of the block \V{b}. Type of block \V{b} must come
out from the type of instruction \V{i} after applying change \V{c}
corresponding to this instruction with function \F{dapply}, as shown in the
type of the block \V{b}. Expression \F{sChg} \V{c} of the type of that
block,
similarly to the previous constructor, transforms instruction-specific
change \V{c} to common machine state diff \F{Diff}. This results into a
block with diff that consists of changes corresponding to instruction \V{i}
and block \V{b}, combined with the function \F{dappend}.
}

\iftoggle{russian-draft}{
Семантика приведенного языка ассемблера определяется двумя функциями,
описывающими семантику инструкций общего назначения \F{Instr} и инструкций
перехода \F{BranchInstr}. Каждому виду инструкций разрешено менять только
часть \emph{состояния программы} \F{State}. Соответственно, эти функции
принимают на вход \emph{состояние программы} и возвращают новое состояние
той части состояния программы, которую им разрешено менять.  Так, для
инструкций общего назначения результатом исполнения является кортеж из
состояния регистров, памяти и стека данных, а результатом исполнения
управляющих инструкций является пара из нового состояния стека вызовов и
следующего блока, который
нужно исполнить. Кроме того, семантика блока кода описывается похожим
образом: результатом исполнения блока является пара из нового состояния
исполнителя и блока, который нужно исполнить следующим.
}{
Semantics of this assembly language is defined by two functions describing
semantics of general-purpose instructions \F{Instr} and branch instructions
\F{BranchInstr}. Each kind of instruction is allowed to change only part of
\emph{program state} \F{State}.
Therefore, these functions take as parameter \emph{program state} and
return a new state of the part of the program state that they are allowed
to change.  For example, the result of an execution of general-purpose
instructions is a tuple of register file, heap and data stack. On the other
hand, the branch instruction execution result is a pair of a new call stack
state and next block to execute.
Moreover, semantics of the block is described in the same manner: block
execution result is a pair of the new machine state and next block to
execute.
}
