\iftoggle{russian-draft}{
Все поддерживаемые типы данных указаны в листинге \ref{fig:types}.
В нашей формализации типы данных описываются двумя разными Agda-типами:
\F{WordType} и \F{ArbitraryType}. Agda-тип \F{WordType} описывает только типы размером с
регистр и используется для корректной типизации таких инструкций, как,
например, копирование значения в регистр из ячейки памяти, которая может быть
потенциально произвольного размера. Agda-тип \F{ArbitraryType}
описывает типы произвольного размера, которые включают в себя типы размером
с регистр с помощью конструктора \C{atom}.

Действительно необходимой для формализации динамической линковки является
семантика инструкции непрямого перехода, позволяющая динамически менять
целевую точку передачи исполнения. Аргументом этой инструкции является
указатель на ячейку памяти, в которой находится указатель на блок кода,
который необходимо исполнить. Для корректной типизации этой инструкции в
поддерживаемые типы данных необходимо добавить тип указателя на
типизированную ячейку памяти (конструтор \C{\_*} Agda-типа \F{WordType} в
листинге \ref{fig:types}).  Это является третьим отличием используемой
формализации от оригинального
TAL. По сути, это тип кортежа из оригинального
TAL, но фиксированной длины и без метки инициализированности.

Динамическая линковка добавляет в объектные файлы код-"прослойку" между
различными библиотеками, исполняемый при вызове внешних функций. Этот код
не должен никак влиять на семантику программы. Это означает, что мы не
можем абстрагироваться от стека вызовов, который может быть "испорчен"
вызовом дополнительных процедур. \emph{Состояние программы} оригинального TAL, помимо исполняемой
последовательности инструкций, включало в себя состояния регистров и
памяти. В используемой формализации оно дополнительно включает в себя
состояние стека, который для простоты реализации был разделен на две части:
стек данных и стек вызовов. Кроме того, конструктор \C{code} Agda-типа
\F{ArbitraryType}, соответстующий типу последовательности
инструкций, имеет дополнительные аргументы по сравнению с оригинальным TAL.
В используемой формализации аргументами этого конструктора
являются ожидаемые типы регистров, стека данных и стека вызовов, в
то время в оригинальном TAL в аргументах отсутствовали типы стеков.
Это еще одно существенное отличие
используемой формализации от оригинального TAL.
}{
\textbf{TODO}.

What is really necessary for dynamic linking formalization is indirect jump
instruction semantics. This instruction allows to dynamically change target
executable code. The argument of this instruction is a pointer to a memory
location where the address of target executable code is stored. To
correctly type indirect jump instruction we need to support the type of
pointer to typed memory (the type \C{\_*} from listing \ref{fig:types}).
This is the third difference from the original Typed Assembly Language.
Essentially, this is the tuple type from the original TAL, but without
initialization flag and of fixed length.

\textbf{\emph{TODO:}}
Dynamic linker adds intermedium code between different libraries. This code
is called when external function is called. It must not affect program
semantics. Therefore, we can't hide call stack in abstractions, because it
can be affected by additional procedure calls. \emph{Programs} of original TAL
includes \emph{instruction sequence}, \emph{register files} and \emph{heaps}. Our
formalization additionally includes \emph{stack}, which is split in two parts:
\emph{data stack} and \emph{call stack}. Instruction sequence type from original TAL
contained only expected \emph{register file type}, but in our formalization
it contains also types of expected data stack and call stack, as shown
in \C{code} constructor of listing \ref{fig:types}. This is another
difference from original TAL.
}

\iftoggle{russian-draft}{
Часть \emph{состояния программы}, не содержащую исполняемой последовательности инструкций,
будем называть \emph{состоянием исполнителя}. Определение Agda-типа
\F{StateType}, описывающего тип состояния исполнителя, приведенo в листинге
\ref{fig:statetype}.
Типы регистров, описываемые Agda-типом \F{RegFileTypes}, как и в оригинальном
TAL и STAL, описываются отображением из имен регистров в соответствующие
им типы. Аналогично, типы элементов в памяти, описываемые Agda-типом
\F{HeapTypes} - это отображение из
указателей (меток) в соответствующие им типы. Типы стека данных,
описываемые Agda-типом \F{DataStackType}, как и в STAL, описываются списком
типов, соответствующим находящимся на стеке элементам. Типы стека вызовов,
описываемые типом \F{CallStackType}, описываются похожим списком,
определяющим типы
указателей-адресов возврата. Так как данная статья фокусируется на описании
семантики динамической линковки, детали реализации на Agda этих отображений
здесь не описаны.

Разные инструкции меняют различные части состояния исполнителя. Инструкции,
определяющие, какой код будет исполняться дальше, будем называть
\emph{инструкциями перехода}, а все остальные инструкции —
\emph{инструкциями общего назначения}.

Так как линковка принимает во внимание только переходы между различными
частями загруженного в память кода, удобно ввести понятие \textbf{\emph{базового
блока}}. Базовым блоком мы будем называть последовательность инструкций
общего назначения, завершающуюся инструкцией перехода. Этому понятию
соответствует термин \emph{последовательность инструкций}
(\emph{instruction sequence}) из оригинального TAL. Тип базового блока
задается конструктором \C{code} Agda-типа \F{ArbitraryType} из листинга
\ref{fig:types} и описывает, в каком состоянии исполнителя может быть
исполнен этот блок.

Для обеспечения корректности вызова функции $g$ в конце
базового блока $f$ необходимо понимать, как блок $f$ типа $S_f$ меняет
типы регистров и стеков и может ли он к концу своего исполнения получить
ожидаемый функцией $g$ тип $S_g$. Для этого Agda-тип блока индексирован
некоторым описанием того, как этот блок меняет тип состояния
исполнителя. Это описание хранится в Agda-типе
\F{Diff}, параметром которого является тип состояния исполнителя, к
которому может применяться это изменение.
Индуктивное определение Agda-типа \emph{блока кода} приведено в листинге
\ref{fig:block}. Конструктор \C{↝} позволяет получить блок, состоящий из
одной инструкции перехода \V{i}, применяющей изменение стека вызовов типа
\V{c}. В сигнатуре этого конструктора выражение \F{csChg} \V{S}
\V{c} преобразовывает изменение стека вызовов \V{c} в общее
изменение \F{Diff} состояния исполнителя типа \V{S}.
Конструктор \C{\_∙\_} добавляет инструкцию общего назначения \AgdaBound{i} с
изменением \AgdaBound{c} к началу блока \AgdaBound{b}. При этом тип блока
\AgdaBound{b} должен получаться из типа инструкции \AgdaBound{i} после
применения к нему соответствующего этой инструкции изменения \V{c} с
помощью функции \F{dapply}, что показано в типе блока \V{b}. В типе этого
блока выражение \F{sChg} \V{c}, аналогично предыдущему конструктору,
преобразовывает специфичное для инструкции \V{i} изменение \V{c} в общее
изменение состояния исполнителя, описываемое Agda-типом \F{Diff}. В
результате получается блок с изменением, составленным с помощью функции
\F{dappend} из изменений инструкции \AgdaBound{i} и блока \AgdaBound{b}.

Семантика приведенного языка ассемблера определяется двумя функциями,
описывающими семантику инструкций общего назначения \F{Instr} и инструкций
перехода \F{ControlInstr}. Каждому виду инструкций разрешено менять только
часть \emph{состояния программы} \F{State}. Соответственно, эти функции
принимают на вход \emph{состояние программы} и возвращают новое состояние
той части состояния программы, которую им разрешено менять.  Так, для
инструкций общего назначения результатом исполнения является кортеж из
состояния регистров, памяти и стека данных, а результатом исполнения
управляющих инструкций является пара из нового состояния стека вызовов и
следующего блока, который
нужно исполнить. Кроме того, семантика блока кода описывается похожим
образом: результатом исполнения блока является пара из нового состояния
исполнителя и блока, который нужно исполнить следующим.
}{
\textbf{TODO: block}

\emph{Machine state} is the part of the \emph{program} that does not
contain \emph{instruction sequence}. Its type is shown in listing
\ref{fig:statetype}. \textbf{TODO}

\textbf{TODO: block}

To ensurre that function $g$ call in the end of the \emph{block}
(\emph{instruction sequence}) $f$ is correct, we have to know how block $f$
of type $S_f$ changes register file types and stack types and whether it
can transform machine state type $S_f$ to expected by function $g$ machine
state type $S_g$. To achieve this, type of block should contain not only
expected types of register file and stack, but some description of how this
block changes differnet parts of machine state type. This description is
stored in datatype \F{Diff}, which takes as parameter machine state type
that can be changed by this \emph{diff}. Recursive definitoin of the
\emph{code block} is shown in listing \ref{fig:block}. \textbf{TODO}

Semantics of this assembly language is defined by two functions describing
semantics of regular instructions (\emph{instructions} from original TAL)
and branch instructions (last instructions in \emph{instruction sequence}
from original TAL). Each type of instruction is allowed to change only part
of \emph{program}, and execution result is described by the new state of
that part of the \emph{program}. So, some branch instruction execution
result is a pair of new call stack state and next block to execute.
Moreover, semantics of the block is described in the same manner: block
execution result is a pair of the new machine state and next block to
execute. TODO
}
