# Typed Assembly Language

Кажется, с него все и пошло. Некоторый низкоуровневый язык со своей
семантикой; что делает его действительно низкоуровневым, так это
использование регистров и примитивных инструкций. Над ним есть много разных
расширений, от зависимых типов до различных уровней конфиденциальности
данных.

Программы в нем представляются тройкой из состояний памяти, регистров и
исполняющейся последовательности инструкций.

Пока пилили компилятор TAL, параллельно запилили low-level язык,
позволяющий делать pointer aliasing и при этом безопасно делать
деструктивные операции. Интересно с точки зрения имплементации
типизированной памяти, но пока это меня не слишком интересует. 

У TAL есть еще расширение, позволяющее работать со стеком.

Мою же работу можно рассматривать как формализацию чего-то почти такого на
агде в виде расширяемого (в плане поддерживаемых инструкций) фреймворка.
Только в том месте, в котором у TAL красивая типизация с переменными типов,
у меня все грустно. "Эталонная" реализация сделана на OCaml + C, если
верить тому, что лежит на гитхабе. И, кажется, на пруфчекерах его никто не
писал.

Есть еще MTAL, который формализует внутри себя type-safe раздельную
компиляцию, представляя добавляя в TAL-файлы export- и import-символы. Но
они ничего не сделали про динамическую линковку:
*   "We believe that our model should extend to incorporate dynamic loading."
*   "An important technical issue with dynamic loading is that we must
    extend our evaluation relation to support execution on program states
    with unresolved labels." TODO: evaluation relation
1999 год, ни слова про future work

# CompCert

Компилятор сей, написан на Coq, делает доказанно корректные оптимизации. В
качестве линкера дергает системный. В 2015 году какие-то чуваки делали
стесс-тесты на link time optimisations, используя интерпретатор C из
CompCert, детектящий undefined behavior. ЧСХ, при этом они умудрились
найти пару багов в самом CompCert (что, впрочем, не имеет отношения к
линковке, что ожидаемо).

У них внутри (на 2009 год) последним внутренним представлением является
свой AST для языка ассемблера PowerPC, в который они делают трансляцию с
сохранением семантики. При этом система типов у них становится дико
примитивной почти без всяких проверок еще на достаточно высоком уровне
абстракции, чуть ли не в первой половине внутренних представлений, которые
они используют, поэтому их ассемблерное AST мало чем примечателен. Потом
они не-верифицированно pretty-print-ят это AST и не-верифицированно
линкуют.

# Vellvm

Формализация внутреннего представления LLVM с верифицированными
оптимизациями. А еще они ковыряли модель памяти. Про трансляцию в ассемблер
ничего не делали.

# Bedrock

“Типизированный ассемблер” на Coq, подходящий для написания корректных
low-level программ. Они внутри себя формализовали логику Хоара, навернули
на неё сверху separation logic (которая про формализацию всякой работы с
памятью) и делают код в формате “прекондишн-код-посткондишн”.

Делали какие-то потуги с линковкой с кодом на других языках (“Compiler
Verification Meets Cross-Language Linking Via Data Abstraction”), и у них
это выглядит как-то НЕ ОЧЕНЬ: для вызова внешней функции (да и для indirect
call тоже) они ставят post-condition, указывающий, что исполнение
продолжится с продолжения этого кода. Но на самом-то деле хочется знать,
что будет исполняться вызываемая функция, а потом уже продолжение кода!
Немножко печалька.

А вообще, они прямо функции линкера встраивают в свои скомпилированные
программы. Ну допустим, а как линковать внешние функции?

Ну и опять же, у них там ничего про динамическую линковку (что странно,
ведь они используют тот же подход, что и с GOT/PLT, только называют это
почему-то очень модным термином data abstraction)

Вообще-то, рантайм-кусок линкера вполне можно было бы написать и на этом.
Но линкер должен оперировать абстракцией "код" и "инструкция" сам по себе,
должен оперировать всякими AST для генерации нужного кода. Кажется, Bedrock
нам такого не даст.
