\iftoggle{russian-draft}{
\section{Обзор используемой формализации TAL}
}{
\section{TAL formalization overview}
}

\label{sec:asm-review}

\textbf{TODO: why TAL}

\textbf{TODO: we won't specify our language}

\iftoggle{russian-draft}{
Оригинальный Typed Assembly Language (TAL) достаточно выразителен для
реализации возможностей высокоуровневых языков, таких как параметрический
полиморфизм или пользовательские структуры данных. Для нашей задачи эти
возможности не являются существенными, но вместо этого возникает
необходимость наличия определенных типов данных и инструкций, используемых
в реализации динамической линковки. В связи с этим используемая
формализация TAL имеет несколько существенных отличий от оригинального
Typed Assembly Language, синтаксис которого приведен в
}{
Original Typed Assembly Language (TAL) is powerful enough to implement high-level
language features such as parametric polymorphism or records. These features
are not necessary for our task. Instead, we ought to have specific data
types and instructions which are typically used to implement dynamic
linking. Therefore, our TAL formalization has some differences from
original Typed Assembly Language. The syntax of TAL can be found in
}
\citep[fig. 13]{tal}.

\iftoggle{russian-draft}{
Прежде чем описывать особенности используемой формализации, сделаем
пару замечаний по используемой терминологии.
В разных версиях TAL текущее состояние исполняемой программы называлось
по-разному: в TAL и STAL оно называлось \emph{программой (program)}
\citep[fig. 13]{tal} \citep{stal}, в то
время как в MTAL его называли \emph{состоянием программы (program state)}
\citep{mtal}.
Мы будем его называть \emph{\textbf{состоянием программы}}.
Кроме того, слово ``тип'' может быть использовано для описания сущностей из
разных слоев абстракции: оно может как ссылаться на сущность в коде на
Agda, так и на сущность ``тип'' из TAL. Чтобы избежать путаницы, ссылаться на
типы из Agda мы будем с помощью фразы Agda-тип.
}{
Before describing features of our formalization, we will make some remarks
about terminology used in this paper. In different TAL versions current
state of executed program was called differently: in TAL and STAL it was
called \emph{program} \citep[fig. 13]{tal} \citep{stal}, whereas in MTAL it
was called \emph{program state} \citep{mtal}. We will call it
\emph{\textbf{program state}}.
Aside from that, the word ``type'' can be used to refer to different items
from different abstraction layers: it can refer to types from Agda code as
well as types from TAL. We will refer to types from Agda code as
``Agda-type''.
}

\textbf{TODO: simplify}

\iftoggle{russian-draft}{
Первым отличием используемой формализации от оригинального TAL
является отсутствие параметров типов. Это является
значительным упрощением исходного языка, позволяющим сильно упростить
используемую формализацию. Тем не менее, динамический линковщик не
нуждается в полиморфизме на уровне языка ассемблера: он не интерпретирует и
не меняет данный ему код, всего лишь добавляя к нему дополнительные
элементы.

Вторым отличием является отсутствие кортежей в памяти, в которых
динамический линковщик также не нуждается. Вместе с типом кортежа из языка
удаляются неинициализированные значения и метки инициализированности.
}{
The first difference of TAL and our formalization is the lack of type
variables. It greatly simplifies
original TAL language and allows to simplify our formalization. However,
dynamic linker does not need polymorphism at assembly language level: it
does not interpret and does not change input code, only appending
additional elements to it.

The lack of tuples is the second difference. Dynamic linker does not need
it either. Uninitialized ``garbage'' values and initialization flags are
deleted from language along with tuple type.
}
