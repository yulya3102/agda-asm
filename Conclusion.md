# Discussion

В этой статье формализована на Agda простая модель динамической линковки,
описывающая изменения кода программ и библиотек, производимые линкером. В
этой формализации сформулированы основные свойства динамического
линковщика:

*   Описано, как динамический линковщик меняет layout программы и какие
    элементы он в нее добавляет (функция \F{pltize}).
*   Зная, по какому смещению в неслинкованном объектном файле располагался
    некоторый блок кода, динамический линковщик может сказать, где этот
    блок кода будет располагаться в динамически слинкованной библиотеке
    (функция \F{func}).
*   Зная идентификатор функции (в данной простой реализации это
    просто смещение в объектном файле), динамический линкер может указать
    на соответствующие этой функции элементы GOT и PLT (функции \F{got} и
    \F{plt}). Так как эта информация известна в link-time, становится
    возможным использовать их на этом этапе: заменять вызовы "неизвестных"
    функций на вызовы известных блоков PLT, выполнять link-time
    оптимизации.
*   Заранее известно, какой именно код динамический линковщик генерирует
    для каждой внешней функции (функция \F{plt-stub}), а значит, можно
    рассуждать про семантику этого кода.
*   Корректность работы динамической линковки полагается на корректность
    работы динамического загрузчика, при этом явно формулируется,
    выполнение каких свойств требуется в рантайме (функции \F{GOT[ f
    ]-correctness}, \F{PLT[ f ]-correctness})
*   Доказано, что динамическая линковка не меняет семантику программы.

Эти формальные требования позволяют говорить о корректности выполненной
динамической линковки библиотек и могут служить основой для написания
формально верифицированных динамического линковщика и динамического
загрузчика.

(тут должна быть какая-то логическая связка - переход от "что сделано в
статье" к "что неплохо было бы еще сделать")

***ABI ленивой линковки***.
Современные библиотеки формата ELF используют так называемую "ленивую"
линковку, позволяющую загружать библиотеки в память при первом обращении к
ним. Это требует изменения кода блоков PLT соответстующим образом, и
нуждается в несколько усложненной формализации.

***Алгоритм линковки***.
В статье совершенно не затрагивается сам процесс заполнения релокаций
динамическим загрузчиком. Приведенная формализация нуждается в формальном
описании процесса заполнения релокации и его свойств, как это сделано в
[@cardelli].

***Алгоритм динамической загрузки***.
Для получения realistic dynamic linker/loader необходима формализация
частей его работы, не связанных с линковкой напрямую: разбор бинарных
файлов существующих форматов such as ELF и формализация загрузки бинарного
кода в память и взаимодействие с операционной системой на этом этапе.

(а тут должен быть логический переход к "на что уже сущестующее можно
повлиять")

***Link-time optimizations***.
Продложение этой работы может существенно повлиять на LTO, не имеющего
на данный момент формально описанной семантики (**TODO: proofs?**).
Кроме того, это позволило бы построить тулчейн с CompCert, покрывающий
гарантиями не только трансляцию кода, но и линковку и связанные с ней
оптимизации.

***Typed Assembly Language***.
Одно из расширений TAL, описанное в [@mtal], формализует типобезопасную
статическую линковку. Продолжение данной работы могло бы расширить TAL еще
сильнее, добавив формализацию типобезопасной динамической линковки.
