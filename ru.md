## RegTypes and MemType declaration

TODO

## StateType definition

Как было сказано ранее, состояние исполнителя состоит из трех частей:
регистров, памяти и стека. Стек мы решили поделить на две части, значит,
теперь состояние типов будем задавать как четыре части: регистры, память,
стек вызовов и стек данных.

## CallStackType should refer to itself

Тип стека вызовов должен представлять собой стек типов его элементов.
Элементом стека вызовов являются указатели на блоки кода, а типом блока
кода является тип состояния исполнителя, требуемый для корректного
исполнения данного блока. И тут-то кроется проблема: тип состояния
исполнителя включает в себя тип стека вызовов, который мы сейчас и пытаемся
определить. Значит, в качестве типа элемента стека вызовов необходимо
использовать что-то другое.

Элемент стека вызовов может быть использован только в одном случае: если
над стеком вызовов типа (ip :: CS) была произведена операция pop, достающая
элемент типа ip из стека, при этом после выполнения этой операции тип стека
вызовов будет CS. Операция pop должна быть продолжена исполнением блока
кода, тип стека вызовов которого является CS. Если pop из стека вызовов
произошел в результате исполнения инструкции ret, то исполнение продолжит
блок, указанный в вытащенном из стека элементе. При этом у нас без изучения
типа ip есть ограничение на тип стека вызовов этого элемента, а значит,
можно считать, что тип стека вызовов для элементов, лежащих в нем, задан
неявно: он равен тому, что останется от типа стека вызовов после
вытаскивания заданного элемента. Таким образом, в качестве типа элемента
стека вызовов можно использовать тип состояния исполнителя указанного блока
без типа стека вызовов. Так как тип памяти не изменяется в течение
исполнения программы, в типе элемента стека вызовов он тоже не указан.

## Формализация конкретного ассемблера

TODO

## Эквивалентность блоков кода

Конечной целью всего этого дела является формализация какой-то
эквивалентности программ. Какие две программы считать эквивалентными? Нам
хочется думать, что эквивалентными являются те программы, которые одинаково
исполняются. Рассмотрим следующий пример:

```asm
    main:
        call f
        mov rax, 1
        ret

    f:
        nop
        ret
```

```asm
    main:
        mov rax, 1
        ret
```

Эти программы исполняются одинаково в том смысле, что на момент завершения
обоих программ состояние исполнителя будет абсолютно одинаковым, если они
были одинаковыми на момент запуска программ. Для того, чтобы определять
эквивалентность программ, определим эквивалентность блоков. Для приведенных
выше программ блоки `main` будут эквивалентны, так как одинаковые состояния
исполнителя переводят в одинаковые состояния исполнителя.

Напомним, что тип блока соответствует типу состояния исполнителя, из
которого его корректно запускать. Тип состояния исполнителя при этом
включает тип памяти. Отсюда следует, что блоки в разных программах, скорее
всего, будут иметь разные типы и не будут эквивалентными. Поэтому
технически имеет смысл разговаривать только о разных блоках внутри одной
программы, хотя ничто не мешает думать, что разные программы можно слить в
одну (с альфа-конверсией) и доказывать эквивалентность блоков внутри нее.

Вспомогательное определение: *исполняемым блоком* я буду называть пару из
блока какого-то типа `T` и состояния исполнителя того же типа `T`. Про
исполнение таких блоков уже можно доказывать, ведь ход исполнения точно
известен, даже если внутри есть какие-то ветвления. Два исполняемых блока
будем считать эквивалентными, если существует последовательность исполнений
блоков, приводящая к одному и тому же исполняемому блоку. Это является
частным случаем бисимуляции. При таком определении, например, эквивалентны
следующие блоки кода при определенных состояниях исполнителя:

```asm
    f:
        mov rax, 2
        ret
```

```asm
    f:
        mov rbx, 1
        ret
```

Но, например, для предыдущего примера исполняемые блоки `main` будут
эквивалентны при любых одинаковых состояниях исполнителя. И это и будет
определением эквивалентности блоков: если для любых одинаковых состояний
исполнителя существуют последовательности исполнения исполняемых блоков,
приводящие к одному и тому же исполняемому блоку, то эти блоки
эквивалентны.

(красивая диаграммка с последовательностью исполнений блоков)

*Программой* будем считать набор блоков с заданным стартовым блоком. Две
программы эквивалентны, если их стартовые блоки эквивалентны.

Такая эквивалентность блоков является частным случаем бисимуляции, а
бисимуляция является подстановочной. Значит, в программе можно заменить
блоки на эквивалентные им без изменения результата.

## Эквивалентность статически и динамически слинкованных программ

Так как в качестве программы мы рассматриваем набор блоков в памяти, а не
набор объектных файлов на ФС, говорить о линковке как таковой странно. Но
это нам и не нужно, ведь мы говорим только об ABI, а оно не меняется при
переходе от бинарных файлов к загруженным в память блокам.

В статически слинкованной программе никаких трудностей с вызовом функций
нет, все функции вызываются напрямую. С другой стороны, в динамической
линковке функции вызываются через соответствующие им блоки PLT.
Указанную эквивалентность предполагается доказывать следующим образом:

*   Предположим, что добавление каких-то новых данных в память не влияет на
    исполнение. Тогда статически слинкованная программа эквивалентна
    статически слинкованной программе с добавленными в память GOT и PLT.
*   Докажем, что блок, делающий `call` функции напрямую, эквивалентнен
    блоку, делающему `call` соответствующего этой функции блоку PLT.
*   Определенное отношение эквивалентности подстановочно, потому в
    статически слинкованной программе с добавленными в память GOT и PLT
    можно заменить вызовы функций на вызовы соответтвующих им блоков PLT.
*   Полученная в предыдущем пункте программа по определению является
    динамически слинкованной программой.

## Формализация ABI статически слинкованных программ

Статическая линковка не добавляет никаких изменений в программу, потому
статически слинкованным кодом можно считать любой код, в котором нет
неразрешенных символов. Так как в наших формализациях рассматриваются
программы уже после загрузки в память, в них по определению никаких
неразрешенных символов быть не может. Поэтому можно считать, что любая
программа, формализованная на типизированном ассемблере, слинкована
статически.

## Формализация ABI динамически слинкованных программ

Динамическая линковка добавляет некоторое количество изменений к коду,
описанных выше, а именно:

*   на каждую функцию добавляются соответствующие ей элементы GOT и PLT;
*   все вызовы функций заменяются на вызовы соответствующих блоков PLT.

Программа, к которой применены эти преобразования, считается динамически
слинкованной.

## Доказательство эквивалентности

Сначала можно доказать несколько достаточно общих теорем про исполнение
заданного ассемблера, например, доказать эквивалентность любого блока `f`
блоку, который делает `jmp f`. В нашем случае более важным является
доказательство эквивалентности любого блока `f` блоку, делающему indirect
jump по адресу, в котором записан адрес `f`. По определению indirect jump
не меняет состояние исполнителя, только переходит на блок, указанный в
ячейке памяти по данному адресу, и это и будет последовательностью
исполнений, приводящей к одному и тому же исполняемому блоку.

Очевидно, частным случаем этой эквивалентности является эквивалентность
функции и ее блока PLT, что и является искомой эквивалентностью.
