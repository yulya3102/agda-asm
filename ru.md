## Blocks definitions

TODO

## Формализация конкретного ассемблера

TODO

## Эквивалентность статически и динамически слинкованных программ

Так как в качестве программы мы рассматриваем набор блоков в памяти, а не
набор объектных файлов на ФС, говорить о линковке как таковой странно. Но
это нам и не нужно, ведь мы говорим только об ABI, а оно не меняется при
переходе от бинарных файлов к загруженным в память блокам.

В статически слинкованной программе никаких трудностей с вызовом функций
нет, все функции вызываются напрямую. С другой стороны, в динамической
линковке функции вызываются через соответствующие им блоки PLT.
Указанную эквивалентность предполагается доказывать следующим образом:

*   Предположим, что добавление каких-то новых данных в память не влияет на
    исполнение. Тогда статически слинкованная программа эквивалентна
    статически слинкованной программе с добавленными в память GOT и PLT.
*   Докажем, что блок, делающий `call` функции напрямую, эквивалентнен
    блоку, делающему `call` соответствующего этой функции блоку PLT.
*   Определенное отношение эквивалентности подстановочно, потому в
    статически слинкованной программе с добавленными в память GOT и PLT
    можно заменить вызовы функций на вызовы соответтвующих им блоков PLT.
*   Полученная в предыдущем пункте программа по определению является
    динамически слинкованной программой.

## Формализация ABI статически слинкованных программ

Статическая линковка не добавляет никаких изменений в программу, потому
статически слинкованным кодом можно считать любой код, в котором нет
неразрешенных символов. Так как в наших формализациях рассматриваются
программы уже после загрузки в память, в них по определению никаких
неразрешенных символов быть не может. Поэтому можно считать, что любая
программа, формализованная на типизированном ассемблере, слинкована
статически.

## Формализация ABI динамически слинкованных программ

Динамическая линковка добавляет некоторое количество изменений к коду,
описанных выше, а именно:

*   на каждую функцию добавляются соответствующие ей элементы GOT и PLT;
*   все вызовы функций заменяются на вызовы соответствующих блоков PLT.

Программа, к которой применены эти преобразования, считается динамически
слинкованной.

## Доказательство эквивалентности

Сначала можно доказать несколько достаточно общих теорем про исполнение
заданного ассемблера, например, доказать эквивалентность любого блока `f`
блоку, который делает `jmp f`. В нашем случае более важным является
доказательство эквивалентности любого блока `f` блоку, делающему indirect
jump по адресу, в котором записан адрес `f`. По определению indirect jump
не меняет состояние исполнителя, только переходит на блок, указанный в
ячейке памяти по данному адресу, и это и будет последовательностью
исполнений, приводящей к одному и тому же исполняемому блоку.

Очевидно, частным случаем этой эквивалентности является эквивалентность
функции и ее блока PLT, что и является искомой эквивалентностью.
