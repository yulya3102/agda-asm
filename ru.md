## Зачем мне нужен свой типизированный ассемблер, и каким он должен быть

Проблема в том, что доказывать что-то про сам линкер не очень-то полезно:
нас интересует корректность не линкера, а слинкованных программ (при
условии корректности исходных программ). Для этого нам нужно, чтобы
абстракции, используемые в доказательстве, и то, что используется в
реальном коде, имело что-то, очень близкое к соответствию один-в-один. Это
подводит нас к тому, что для формализации доказательств про линковку
необходим формализованный типизированный ассемблер, который выглядит
практически так же, как выглядел бы реальный ассемблер, который можно
странслировать напрямую в машинный код и запустить.

Кроме того, формализация линковки нуждается в четырех концепциях:

*   инструкция `call`;
*   инструкция `jmp[]`;
*   память с адресуемым кодом;
*   память с адресуемыми данными.

Инструкция `call` (вызов функции) является ключевой для всего этого
праздника, ведь линковка и ее проблемы возникают как раз там, где
происходит вызов функций между разными объектными файлами.

Инструкция `jmp[]` (непрямой jump) является типичным решением проблем в
динамической линковке. В рантайме куда-то (это место обычно называют GOT)
записываются адреса загруженных из объектных файлов функций (и это и есть
то, почему нам нужен адресуемый код), а при непосредственном вызове функции
происходит непрямой jump по адресу, записанному в GOT (и здесь нам нужны
адресуемые данные). 

Адресуемый код нужен, чтобы в GOT можно было сохранить что-то, гхм,
указывающее на нужные куски кода, то есть адреса.

Адресуемые данные нужны, чтобы их можно было засунуть в непрямой jump.

## Зачем надо мета-ассемблер

Как было сказано ранее, нам необходим формализованный типизированный
ассемблер, который очень похож на реальный код. Беда в том, что писать его
для каждого набора инструкций слишком трудоемко, потому было бы разумно
выделить некоторую общую часть формализации какого-то конкретного
ассемблера, обобщить ее и сделать максимально переиспользуемой. Назовем эту
часть "мета-ассемблером".

Частью, разнящейся от ассемблера к ассемблеру, является конкретный набор
инструкций вместе с семантикой его исполнения. Остальное — концепции
памяти, регистров и стека — является общим и может быть определено один раз
для всех ассемблеров.

Реализованный "мета-ассемблер" формализует общие концепции (память, блоки
кода, регистры) как параметризованные набором инструкций агда-модули.
Таким образом, конкретный ассемблер можно получить, всего лишь формализовав
его набор инструкций и затем заимпортив нужный модуль с нужными
параметрами.

"Мета-ассемблер" включает в себя:

*   блоки кода;
*   регистры и "малые" значения, которые могут находиться в регистрах;
*   память и значения, которые могут лежать в памяти;
*   семантику исполнения заданного блока кода.

## Эквивалентность блоков кода

Конечной целью всего этого дела является формализация какой-то
эквивалентности программ. Какие две программы считать эквивалентными? Нам
хочется думать, что эквивалентными являются те программы, которые одинаково
исполняются. Рассмотрим следующий пример:

```asm
    main:
        call f
        mov rax, 1
        ret

    f:
        nop
        ret
```

```asm
    main:
        mov rax, 1
        ret
```

Эти программы исполняются одинаково в том смысле, что на момент завершения
обоих программ состояние исполнителя будет абсолютно одинаковым, если они
были одинаковыми на момент запуска программ. Для того, чтобы определять
эквивалентность программ, определим эквивалентность блоков. Для приведенных
выше программ блоки `main` будут эквивалентны, так как одинаковые состояния
исполнителя переводят в одинаковые состояния исполнителя.

Напомним, что тип блока соответствует типу состояния исполнителя, из
которого его корректно запускать. Тип состояния исполнителя при этом
включает тип памяти. Отсюда следует, что блоки в разных программах, скорее
всего, будут иметь разные типы и не будут эквивалентными. Поэтому
технически имеет смысл разговаривать только о разных блоках внутри одной
программы, хотя ничто не мешает думать, что разные программы можно слить в
одну (с альфа-конверсией) и доказывать эквивалентность блоков внутри нее.

Вспомогательное определение: *исполняемым блоком* я буду называть пару из
блока какого-то типа `T` и состояния исполнителя того же типа `T`. Про
исполнение таких блоков уже можно доказывать, ведь ход исполнения точно
известен, даже если внутри есть какие-то ветвления. Два исполняемых блока
будем считать эквивалентными, если существует последовательность исполнений
блоков, приводящая к одному и тому же исполняемому блоку. Это является
частным случаем бисимуляции. При таком определении, например, эквивалентны
следующие блоки кода при определенных состояниях исполнителя:

```asm
    f:
        mov rax, 2
        ret
```

```asm
    f:
        mov rbx, 1
        ret
```

Но, например, для предыдущего примера исполняемые блоки `main` будут
эквивалентны при любых одинаковых состояниях исполнителя. И это и будет
определением эквивалентности блоков: если для любых одинаковых состояний
исполнителя существуют последовательности исполнения исполняемых блоков,
приводящие к одному и тому же исполняемому блоку, то эти блоки
эквивалентны.

(красивая диаграммка с последовательностью исполнений блоков)

*Программой* будем считать набор блоков с заданным стартовым блоком. Две
программы эквивалентны, если их стартовые блоки эквивалентны.

## TODOs

Такая эквивалентность блоков является частным случаем бисимуляции, а
бисимуляция является подстановочной. Значит, в программе можно заменить
блоки на эквивалентные им без изменения результата.

## Эквивалентность статически и динамически слинкованных программ

Так как в качестве программы мы рассматриваем набор блоков в памяти, а не
набор объектных файлов на ФС, говорить о линковке как таковой странно. Но
это нам и не нужно, ведь мы говорим только об ABI, а оно не меняется при
переходе от бинарных файлов к загруженным в память блокам.

В статически слинкованной программе никаких трудностей с вызовом функций
нет, все функции вызываются напрямую. С другой стороны, в динамической
линковке функции вызываются через соответствующие им блоки PLT.
Указанную эквивалентность предполагается доказывать следующим образом:

*   Предположим, что добавление каких-то новых данных в память не влияет на
    исполнение. Тогда статически слинкованная программа эквивалентна
    статически слинкованной программе с добавленными в память GOT и PLT.
*   Докажем, что блок, делающий `call` функции напрямую, эквивалентнен
    блоку, делающему `call` соответствующего этой функции блоку PLT.
*   Определенное отношение эквивалентности подстановочно, потому в
    статически слинкованной программе с добавленными в память GOT и PLT
    можно заменить вызовы функций на вызовы соответтвующих им блоков PLT.
*   Полученная в предыдущем пункте программа по определению является
    динамически слинкованной программой.

## Формализация ABI статически слинкованных программ

Статическая линковка не добавляет никаких изменений в программу, потому
статически слинкованным кодом можно считать любой код, в котором нет
неразрешенных символов. Так как в наших формализациях рассматриваются
программы уже после загрузки в память, в них по определению никаких
неразрешенных символов быть не может. Поэтому можно считать, что любая
программа, формализованная на типизированном ассемблере, слинкована
статически.

## Формализация ABI динамически слинкованных программ

Динамическая линковка добавляет некоторое количество изменений к коду,
описанных выше, а именно:

*   на каждую функцию добавляются соответствующие ей элементы GOT и PLT;
*   все вызовы функций заменяются на вызовы соответствующих блоков PLT.

Программа, к которой применены эти преобразования, считается динамически
слинкованной.

## Доказательство эквивалентности

Сначала можно доказать несколько достаточно общих теорем про исполнение
заданного ассемблера, например, доказать эквивалентность любого блока `f`
блоку, который делает `jmp f`. В нашем случае более важным является
доказательство эквивалентности любого блока `f` блоку, делающему indirect
jump по адресу, в котором записан адрес `f`. По определению indirect jump
не меняет состояние исполнителя, только переходит на блок, указанный в
ячейке памяти по данному адресу, и это и будет последовательностью
исполнений, приводящей к одному и тому же исполняемому блоку.

Очевидно, частным случаем этой эквивалентности является эквивалентность
функции и ее блока PLT, что и является искомой эквивалентностью.
