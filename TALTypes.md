# Обзор используемой формализации TAL

Оригинальный Typed Assembly Language был достаточно выразительным для
реализации возможностей высокоуровневых языков, таких как параметрический
полиморфизм или пользовательские структуры данных. Для нашей задачи эти
возможности не являются существенными, но вместо этого возникает
необходимость наличия определенных типов данных и инструкций, используемых
в реализации динамической линковки. В связи с этим используемая
формализация TAL имеет несколько существенных отличий от оригинального
Typed Assembly Language.

Первым отличием является отсутствие параметров типов. Это является
значительным упрощением исходного языка, позволяющим сильно упростить
используемую формализацию. Тем не менее, динамический линковщик не
нуждается в полиморфизме на уровне языка ассемблера: он не интерпретирует и
не меняет данный ему код, всего лишь добавляя к нему дополнительные
элементы.

Вторым отличием является отсутствие кортежей в памяти, в которых
динамический линковщик также не нуждается. Вместе с типом кортежа из языка
удаляются неинициализированные значения и метки инициализированности.

Действительно необходимой для формализации динамической линковки является
семантика инструкции непрямого перехода, позволяющая динамически менять
целевую точку передачи исполнения. Аргументом этой инструкции является
указатель на ячейку памяти, в которой находится указатель на блок кода,
который необходимо исполнить. Для корректной типизации этой инструкции в
поддерживаемые типы данных необходимо добавить тип указателя на
типизированную ячейку памяти (тип \C{\_*} в листинге \ref{fig:types}), и
это является третьим отличием.

Динамическая линковка добавляет в объектные файлы код-"прослойку" между
различными библиотеками, исполняемый при вызове внешних функций. Этот код
не должен никак влиять на семантику программы. Это означает, что мы не
можем абстрагироваться от стека вызовов, который может быть "испорчен"
вызовом "лишних" процедур. *Программы* оригинального TAL, помимо исполняемой
последовательности инструкций, включали в себя состояния регистров и
памяти. В используемой формализации они дополнительно включают в себя
состояние стека, который для простоты реализации был разделен на две части:
стек данных и стек вызовов. Типы ожидаемых стека данных и стека вызовов так
же добавляются в параметры типа последовательности инструкций (тип
\C{block} в листинге \ref{fig:types}), который в оригинальном TAL содержал
только ожидаемый тип регистров, и это еще одно существенное отличие
используемой формализации от оригинального TAL.

Кроме того, для обеспечения корректности вызова функции $g$ в конце
блока кода $f$ необходимо понимать, как блок $f$ типа $ST_f$ меняет
типы регистров и стеков и может ли он к концу своего исполнения получить
ожидаемый блоком $g$ тип $ST_g$. Для этого тип блока, кроме ожидаемых типов
регистров и стеков, хранит некоторый *дифф* типов, применяемый этим блоком.
Индуктивное определение *блока кода* приведено в листинге \ref{fig:block}.

Часть программы, не содержащая исполняемой последовательности инструкций,
будем называть *состоянием исполнителя*. Тип состояния исполнителя приведен в
листинге \ref{fig:statetype}.

Семантика приведенного языка ассемблера определяется двумя функциями,
описывающими семантику инструкций общего назначения (*instructions* из
оригинального TAL) и инструкций перехода (последние инструкции в
*instruction sequences* оригинального TAL). Каждому виду инструкций
разрешено менять только часть состояния исполнителя, и результатом
исполнения инструкции является новое состояние этой части состояния
исполнителя. Так, для управляющих инструкций результатом исполнения
является пара из стека вызовов и следующего блока, который нужно исполнить.
